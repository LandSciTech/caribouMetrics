---
title: "Notes on Hornseth and Rempel Model"
author: "Sarah Endicott"
output:
  html_document
---
<style>
.vscroll-plot {
    width: 1000px;
    height: 500px;
    overflow-y: scroll;
    overflow-x: hidden;
}
</style>
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Model Information
I have reconstructed the Hornseth and Rempel caribou resource selection probability functions (RSPFs) from several different sources:

* [Horseth and Rempel 2015](https://doi.org/10.1139/cjz-2015-0101)

* Science and Research Internal File Report IFR-01 Rempel and Hornseth 2018

* Create_Caribou_RSPF_Grid LSL script

* Caribou_Range_Specific_RSPF LSL script


The LSL code documents the model used to produce the first two sources but it was also changed later to use FRI data to update the PLC data used in those models to more current conditions. I tried to reconstruct the original model in R and using the LSL script procedures as a guide. However I did not adopt the LSL process of using a hexagonal grid but instead used rasters with square grid cells of equivalent size.

## The Data
Several different data sets are used in the model to describe conditions that affect caribou habitat selection. These include types of forest, wetland, eskers, and linear features. There are also several data sets used to update this information using more recent data and disturbance histories. The table below describes each data set, its source and what it is used for. 

| Name                            | Description                                                     | Purpose                                                                                                                                 | Source                                                                           |
|---------------------------------|-----------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------|
| Provincial land cover (PLC)      | 27 land-cover classes interpreted from 1999 to 2000 imagery     | Grouped into 7 resource types based on patterns believed sufficient to discriminate habitat selection                                   | [link](https://geohub.lio.gov.on.ca/datasets/7aa998fdf100434da27a41f1c637382c)   |
| Eskers                          | Location of eskers                                              | Used to calculate the density of eskers                                                                                                 | Rob Rempel                                                                       |
| Roads                           | Road network                                                    | Combined to calculate density of linear features which was used as a proxy for human disturbance                                        | Josie Hughes MNRFwithORN                                                         |
| Utilities                       | Transmission lines, pipelines etc.                              | Combined to calculate density of linear features which was used as a proxy for human disturbance                                        | [link](https://geohub.lio.gov.on.ca/datasets/mnrf::utility-line)                 |
| Rail                            | Rail network                                                    | Combined to calculate density of linear features which was used as a proxy for human disturbance                                        | [link](https://geohub.lio.gov.on.ca/datasets/mnrf::ontario-railway-network-orwn) |
| Forest resource inventory (FRI) | MNRF data on composition of forests                             | Used to update the PLC based forest type if it had been disturbed since 2001 or if it was disturbed before 2001 and the age is now > 35 | Josie Hughes                                                                     |
| Age                             | Age of forest stands in 10 year classes                         | Used to determine if PLC should be updated                                                                                              | Josie Hughes                                                                     |
| Natural disturbance             | Fire, wind or insect damage since 1990 (ie 10 years before PLC) | Used to determine if PLC should be updated and to set forest classes to 0 if > 35% disturbed                                                                                              | Stephen Mayer, OFRI Disturbance History database                                 |
| Harvest disturbance             | Whether a stand was harvested after PLC data collection         | Used to determine if PLC should be updated and to set forest classes to 0 if > 35% disturbed                                                                                              | Stephen Mayer, OFRI Disturbance History database                                 |
| Anthropogenic disturbance       | Presence of anthropogenic disturbance                           | Used to determine if PLC should be updated and to set forest classes to 0 if > 35% disturbed                                                                                              | Presence of any linear features                                                  |





## Model Overview

There are several steps involved in predicting habitat use using the Hornseth and Rempel RSPF models. These include ensuring all data sets are aligned, reclassifying the PLC and FRI data to resource types, updating the PLC data to FRI data depending on disturbance history, using disturbance proportion to change forest classes, summarizing explanatory variables at a larger scale and calculating the probability of use. All these steps are run with a single call to `caribouHabitat` which in turn calls other functions that are described below.      

### Step 1: Aligning data sets
This is done inside `inputData` which loads and checks the alignment of all data sets (using `checkAlign`) and if they are not already in raster format rasterizes the linear features and eskers based on line density (using `rasterizeLineDensity`). If the data is larger than the project area it will be cropped to the area to save space but if `padProjPoly = TRUE` then it is cropped to a buffer around the project area to prevent edge effects when variables are summarized to a larger scale (using `checkAlign`). 

### Step 2: Reclassifying PLC & FRI
This is done in `processData` based on two look up tables provided with the package: `rfuToResType` and `plcToResType`. They convert regional forest units (RFUs) and PLC classes to resource types. However, FRI data is not always in RFUs so a look up table to convert the FRI forest units to RFUs is provided by the user.

### Step 3: Updating PLC data
This is done by `updatePLC` inside `processData`. The PLC resource type is updated to the resource type from the FRI if there was a natural disturbance in the past and the age in the FRI data is > 35 or there was a harvest after the PLC data was collected. If there was a natural disturbance and the age is < 35 then the PLC resource type is changed to DTN. 

### Step 4: Updating based on disturbance proportion
The second step in `updatePLC` is to convert the PLC data to a 16 ha resolution by layerizing and then using bilinear interpolation so the value in the 16 ha raster is the proportion of that cell covered by the resource type. If > 35%  of a cell is disturbed by either anthropogenic or natural disturbance then values of resource types other than DTN and LGW are set to 0. If > 35% was disturbed by harvest then the values of resource types other than DTN, LGW, LGTP, LGOP and ST are set to 0.

This approach concerns me because it builds in an interdependence among the resource types that may have affected the coefficients in the model. For example if a 16 ha cell was 50% CON and 36% DTN then this process converts it to 0% CON and then in the model this could mean that the effect of CON being 0 is more important than the amount of DTN rather than if it was kept as 50% the model could determine that the effect of DTN might be greater than the effect of CON so even though CON is high the cell would have low caribou use. With the data modified like this these effects might be harder to detect. I am also concerned that this might affect the coefficient for TDENLF since roads are correlated with harvest but areas with harvest > 35% also have forest values set to 0. This issue is somewhat lessened by the fact that the next step summarizes habitat over a 5000 or 10 000 ha scale so the 16 ha scale is not the final one. 

### Step 5: Moving window averaging
Following Hornseth and Rempel (2015) habitat selection was determined at a scale of either 5 000 ha or 10 000 ha (_S5 and _S6 in the LSL scripts, respectively). The 16 ha scale is still used to determine whether a cell is selected or not but the values of each resource type in that cell are based on their presence in the larger scale area. To achieve this we used a moving window average of the area around each cell. This is carried out by `movingWindowAvg` inside `processData`. Our version does not exactly follow Hornseth and Rempel's because we did not do the averaging over offsets that they used to "avoid bias from arbitrary boundaries or placement of the 10 000 ha grid set". See the LSL help files for SetGridsetGroup and RescaleGridsetField to get an idea of how this is done. I have implemented this using the `raster::focalWeight` function and then altering the matrix supplied by shifting it to create either 9 or 16 offsets. This is not very elegantly done so far. I also wonder if it would be simpler to create the matrix with a kernal density function that would approximate an infinite number of offsets.   

### Step 6: Calculate probability of habitat use
Using the coefficients for each range and season extracted from the Caribou_Range_Specific_RSPF LSL script I multiplied the coefficients by the explanatory variables and converted from logit to probability to get estimates of habitat use probability for each 16 ha cell. This is done by `calcRSPF` inside `updateCaribou`  

## Updating process in maps
<div class="vscroll-plot">
```{r echo=FALSE, warning=FALSE, message=FALSE}
devtools::load_all()
library(tmap)

pthBase <- "../tests/testthat/data/"

plcD = raster(paste0(pthBase, "plc", ".tif"))
eskerDras = raster(paste0(pthBase, "eskerTif", ".tif"))
friD = raster(paste0(pthBase, "fri", ".tif"))
ageD = raster(paste0(pthBase, "age", ".tif"))
natDistD = raster(paste0(pthBase, "natDist", ".tif"))
anthroDistD = raster(paste0(pthBase, "anthroDist", ".tif"))
harvD = raster(paste0(pthBase, "harv", ".tif"))
linFeatDras = raster(paste0(pthBase, "linFeatTif", ".tif"))
projectPolyD = st_read(paste0(pthBase, "projectPoly", ".shp"), quiet = TRUE)

inData <- caribouHabitat(
  plc = plcD, esker = eskerDras, fri = friD, age = ageD, natDist = natDistD,
  anthroDist = anthroDistD, harv = harvD,
  linFeat = linFeatDras, projectPoly = projectPolyD,
  friLU = read.csv(paste0(pthBase, "friLU", ".csv"), stringsAsFactors = FALSE) %>%
    mutate(RFU = toupper(RFU) %>% stringr::str_replace("HRDMW", "HRDMX")), 
  caribouRange = "Churchill",
  winArea = 500
)

plc = inData@plc; fri = inData@fri; age = inData@age; 
natDist = natDistD; anthroDist = anthroDistD;
harv = harvD; resTypeLevels = raster::levels(inData@plc)[[1]]

if(raster::res(plc)[1] != 250){
  stop("plc must have a resolution of 250m", call. = FALSE)
}

# Add plc class DTN to natDist
DTNcode <- 99

# ATNcode <- resTypeLevels %>% 
#   filter(resType == "ATN") %>% 
#   pull(ID)
# 
# natDist <- natDist == 1 | plc == DTNcode

tmapCatRast(harv, c("No", "Yes"), "Initial harv data")
tmapCatRast(((age > 35) & (natDist == 1)), c("No", "Yes"), "Initial natDist and over 35 data")
tmapCatRast(plc, resTypeLevels$resType, "Initial PLC data")

# Find cells in PLC that meet condition for update: had natDist but have
# age > 35 OR where FRI indicates Harvest (since PLC was created)
toUpdate <- ((age > 35) & (natDist == 1)) | harv == 1

# only update if there is FRI data available
toUpdate <- toUpdate - is.na(fri)

# Update cells in toUpdate in PLC to value in FRI
plc <- mask(plc, mask = toUpdate, maskvalue = 1, 
            updatevalue = NA)

tmapCatRast(plc, resTypeLevels$resType, "To Update PLC data")

plc <- cover(plc, fri)

# remove cells that were updated from natDist
natDist <- mask(natDist, mask = toUpdate, maskvalue = 1, 
                updatevalue = 0)

# update PLC to DTN if natDist and age <= 35
yfNatDist <- (age <= 35| is.na(age)) & natDist == 1

plc <- mask(plc, yfNatDist, maskvalue = 1, 
            updatevalue = DTNcode)

if(!"DTN" %in% resTypeLevels$resType){
      resTypeLevels <- resTypeLevels %>% add_row(resType = "DTN", ID = 99)
    }

tmapCatRast(plc, resTypeLevels$resType, "Post-update PLC to FRI data")

# convert to 16 ha resolution stack of ResType proportion to match 16 ha
# hexagons in Rempel
tmplt <- raster(plc) %>% raster::`res<-`(c(400, 400))
plc <- raster::layerize(plc) %>% 
  raster::resample(tmplt, method = "bilinear") %>% 
  `names<-`(resTypeLevels$resType)

allDist16ha <- raster::stack(harv, anthroDist, 
                             natDist) %>% 
  raster::resample(tmplt, method = "bilinear") %>% 
  `names<-`(c("Harv", "Adist", "natDist"))

qtm(allDist16ha, title = "Resampled to 16 ha Dist data")

# Get proportion of land in 16 ha area that has each type of disturbance
watCode <- resTypeLevels %>% 
  filter(resType == "LGW") %>% 
  pull(ID)

# get proportion land
land <- 1 - plc[[watCode]]

# divide prop disturbance by prop land 
#allDist16ha2 <- allDist16ha / land 

propLandDist <- Vectorize(function(dist, land){
  ifelse(land < dist, 1, 
         ifelse(land == 0, 0, dist/land))
})

allDist16ha <- raster::overlay(allDist16ha, land, fun = propLandDist) %>% 
  `names<-`(c("Harv", "Adist", "natDist"))

qtm(allDist16ha, title = "Resampled to 16 ha Dist data / land")
qtm(plc, title = "Resampled to 16 ha PLC data")
# make plc have 0 forest classes when 16 ha area disturbed > 0.35 by natural
# disturbance or anthropogenic disturbance
toChange <- resTypeLevels %>% filter(!resType %in% c("DTN", "LGW")) %>% 
  pull(ID)

for (i in toChange) {
  plc[[i]] <- raster::mask(plc[[i]], max(allDist16ha[[2:3]] > 0.35),
                           maskvalue = 1, 
                           updatevalue = 0)
}

qtm(plc, title = "PLC data after 0 > 35% DTN")

# make plc have 0 forest classes when 16 ha area disturbed > 0.35 by anthro
# disturbance but don't change wetlands
toChange <- resTypeLevels %>% 
  filter(!resType %in% c("DTN", "LGW", "LGTP", "LGOP", "ST")) %>% 
  pull(ID)

for (i in toChange) {
  plc[[i]] <- raster::mask(plc[[i]], allDist16ha[[1]] > 0.35,
                           maskvalue = 1, 
                           updatevalue = 0)
}
qtm(plc, title = "PLC data after 0 > 35% harv")

```
</div>

## Moving window average with offsetting
The following plots show the weight given to each cell in the window with either 9 or 16 offsets. 
```{r}
mat <- matrix(c(rep(1,5000), rep(2, 5000)), nrow = 100, ncol = 100)
exps <- raster(mat, xmn = 0, xmx = 40000, ymn = 0, ymx = 40000) 
lyrs <- layerize(exps)
pt <- st_sfc(st_point(c(20000, 20000))) %>% st_sf(PID = 1) %>%
  set_names(c("PID", "geometry")) %>% st_set_geometry("geometry")
testRad <- 4000
# Internal of function helpful for interactive testing
cf2 <- focalWeight(lyrs, testRad, "circle")

# add rows to make only far edge points overlap
nToAdd2 <- nrow(cf2)-1
cf2_off <- matrix(0, nrow = nrow(cf2) + nToAdd2, ncol = nrow(cf2) + nToAdd2)

cf2_off5 <- cf2_off
cf2_off5[(nToAdd2/2+1):(nToAdd2/2+nrow(cf2)), (nToAdd2+1):(nToAdd2+nrow(cf2))] <- cf2
cf2_off6 <- cf2_off
cf2_off6[(nToAdd2+1):(nToAdd2+nrow(cf2)), (nToAdd2/2+1):(nToAdd2/2+nrow(cf2))] <- cf2
cf2_off7 <- cf2_off
cf2_off7[0:(nToAdd2+1), (nToAdd2/2+1):(nToAdd2/2+nrow(cf2))] <- cf2
cf2_off8 <- cf2_off
cf2_off8[(nToAdd2/2+1):(nToAdd2/2+nrow(cf2)), 0:(nToAdd2+1)] <- cf2
cf2_off9 <- cf2_off
cf2_off9[(nToAdd2/2+1):(nToAdd2/2+nrow(cf2)), (nToAdd2/2+1):(nToAdd2/2+nrow(cf2))] <- cf2

# find top left edge of circle
test <- FALSE
for (i in 1:nrow(cf2)) {
  x <- which(cf2[i, ] > 0)
  y <- which(cf2[, i] > 0)
  test <- any(x == i & x == y)
  if(test){
    break
  }
}

# make cell at i,i centre add rows and cols all 4 sides
nToAdd <- nToAdd2-i-2

cf2_off1 <- cf2_off
cf2_off1[(nToAdd+1):(nToAdd+nrow(cf2)),(nToAdd+1):(nToAdd+nrow(cf2))] <- cf2 
cf2_off2 <- cf2_off
cf2_off2[(nrow(cf2)-nToAdd):(nrow(cf2)*2-nToAdd-1),(nToAdd+1):(nToAdd+nrow(cf2))] <- cf2
cf2_off3 <- cf2_off
cf2_off3[(nrow(cf2)-nToAdd):(nrow(cf2)*2-nToAdd-1),(nrow(cf2)-nToAdd):(nrow(cf2)*2-nToAdd-1)] <- cf2
cf2_off4 <- cf2_off
cf2_off4[(nToAdd+1):(nToAdd+nrow(cf2)),(nrow(cf2)-nToAdd):(nrow(cf2)*2-nToAdd-1)] <- cf2

nToAdd3 <- nToAdd2 - (i*2 - 1)
nToAdd4 <- nToAdd + (nToAdd - nToAdd3)/2 

cf2_off10 <- cf2_off
cf2_off10[(nToAdd3+1):(nToAdd3+nrow(cf2)),(nToAdd4+1):(nToAdd4+nrow(cf2))] <- cf2 
cf2_off11 <- cf2_off
cf2_off11[(nToAdd4+1):(nToAdd4+nrow(cf2)),(nToAdd3+1):(nToAdd3+nrow(cf2))] <- cf2 

cf2_off14 <- cf2_off
cf2_off14[(nrow(cf2)-nToAdd3):(nrow(cf2)*2-nToAdd3-1),(nToAdd4+1):(nToAdd4+nrow(cf2))] <- cf2 
cf2_off15 <- cf2_off
cf2_off15[(nrow(cf2)-nToAdd4):(nrow(cf2)*2-nToAdd4-1),(nToAdd3+1):(nToAdd3+nrow(cf2))] <- cf2 

cf2_off12 <- cf2_off
cf2_off12[(nrow(cf2)-nToAdd4):(nrow(cf2)*2-nToAdd4-1),(nrow(cf2)-nToAdd3):(nrow(cf2)*2-nToAdd3-1)] <- cf2
cf2_off13 <- cf2_off
cf2_off13[(nToAdd3+1):(nToAdd3+nrow(cf2)),(nrow(cf2)-nToAdd4):(nrow(cf2)*2-nToAdd4-1)] <- cf2

cf2_off16 <- cf2_off
cf2_off16[(nrow(cf2)-nToAdd3):(nrow(cf2)*2-nToAdd3-1),(nrow(cf2)-nToAdd4):(nrow(cf2)*2-nToAdd4-1)] <- cf2
cf2_off17 <- cf2_off
cf2_off17[(nToAdd4+1):(nToAdd4+nrow(cf2)),(nrow(cf2)-nToAdd3):(nrow(cf2)*2-nToAdd3-1)] <- cf2


cf2rasoff1 <- raster(cf2_off1)
cf2rasoff2 <- raster(cf2_off2)
cf2rasoff3 <- raster(cf2_off3)
cf2rasoff4 <- raster(cf2_off4)
cf2rasoff5 <- raster(cf2_off5)
cf2rasoff6 <- raster(cf2_off6)
cf2rasoff7 <- raster(cf2_off7)
cf2rasoff8 <- raster(cf2_off8)
cf2rasoff9 <- raster(cf2_off9)
cf2rasoff10 <- raster(cf2_off10)
cf2rasoff11 <- raster(cf2_off11)
cf2rasoff12 <- raster(cf2_off12)
cf2rasoff13 <- raster(cf2_off13)
cf2rasoff14 <- raster(cf2_off14)
cf2rasoff15 <- raster(cf2_off15)
cf2rasoff16 <- raster(cf2_off16)
cf2rasoff17 <- raster(cf2_off17)


cf2rasoffAll16 <- cf2rasoff4+cf2rasoff1+cf2rasoff2+cf2rasoff3+cf2rasoff5+cf2rasoff6+
  cf2rasoff7+cf2rasoff8+cf2rasoff10+cf2rasoff11+cf2rasoff12+cf2rasoff13+cf2rasoff14+
  cf2rasoff15+cf2rasoff16+cf2rasoff17
cf2rasoffAll16 <- cf2rasoffAll16 / 16

cf2rasoffAll9 <- cf2rasoff4+cf2rasoff1+cf2rasoff2+cf2rasoff3+cf2rasoff5+cf2rasoff6+
  cf2rasoff7+cf2rasoff8+cf2rasoff9
cf2rasoffAll9 <- cf2rasoffAll9 / 9

plot(cf2rasoffAll9, main = "9 Offsets")
plot(cf2rasoffAll16, main = "16 Offsets")



```

